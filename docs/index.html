<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAssembly: Compiler Infrastructure Deep Dive</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container">
            <h1>WebAssembly</h1>
            <p class="subtitle">The Ecosystem as a Compiler Infrastructure</p>
        </div>
    </header>

    <main class="container">
        <section class="intro">
            <h2>Introduction</h2>
            <p>
                For the compiler engineer, WebAssembly (Wasm) is far more than a browser bytecode; it is a portable, stack-based virtual machine (VM)
                that challenges traditional backend assumptions. Unlike register-based ISAs, Wasm enforces <strong>Structured Control Flow</strong> and a
                strict <strong>Harvard Architecture</strong>. This document dissects the ecosystem from an LLVM developer's perspective, exploring the
                impedance mismatches between SSA-based IR and Wasm's validation constraints, and how modern tooling bridges this gap.
            </p>
        </section>

        <section class="content-block">
            <h2>CFG Lowering: The Stackifier vs. Relooper</h2>
            <p>
                LLVM IR models control flow as a Graph (CFG) of Basic Blocks interconnected by arbitrary branches. WebAssembly, however, strictly prohibits
                arbitrary jumps. Execution must follow nested <code>block</code>, <code>loop</code>, and <code>if</code> constructs.
                The <code>br</code> and <code>br_if</code> instructions can only target the labels of these enclosing scopes.
            </p>
            <p>
                The LLVM WebAssembly backend (<code>lib/Target/WebAssembly</code>) solves this impedance mismatch not via the "Relooper" algorithm
                (historically used in JS cross-compilers), but through the <strong>Stackifier</strong> algorithm. The Stackifier topologically sorts basic blocks
                to maximize fall-through opportunities, effectively reconstructing the control flow tree from the CFG. It inserts the minimal set of
                <code>block</code> and <code>loop</code> markers necessary to satisfy Wasm's validation rules while keeping the binary size efficient.
            </p>
        </section>

        <section class="content-block">
            <h2>The Harvard Architecture &amp; Linear Memory</h2>
            <p>
                Unlike the Von Neumann model assumed by most C/C++ lowerings, Wasm separates code and data into distinct index spaces.
                Functions cannot be read or written as bytes, and instruction pointers are not memory addresses.
            </p>
            <p>
                <strong>Function Pointers</strong> are implemented as indices into a specific <code>Table</code> section (e.g., <code>indirect_function_table</code>).
                The <code>call_indirect</code> instruction dynamically validates the callee's type signature at runtime against the caller's expectation.
                This architecture provides coarse-grained <strong>Control Flow Integrity (CFI)</strong> by default, as it is impossible to jump to the middle of a function
                or execute arbitrary data in linear memory.
            </p>
            <p>
                Furthermore, the <strong>Reference Types</strong> proposal (<code>externref</code>) introduces "opaque" values that cannot be stored in linear memory at all.
                This forces the backend to model these values as residing strictly on the operand stack or in global table slots, complicating register allocation strategies
                that traditionally rely on stack spilling.
            </p>
        </section>

        <section class="content-block">
            <h2>Relocation &amp; The Component Model</h2>
            <p>
                Dynamic linking in WebAssembly fundamentally differs from ELF/Mach-O models. Since Wasm modules do not share a unified address space by default,
                the traditional GOT/PLT indirection is replaced by explicit Import/Export matching performed by the runtime.
            </p>
            <p>
                <strong><code>wasm-ld</code></strong> (the LLD port) handles static linking by merging sections and rewriting <code>memory.init</code> segments.
                However, for composability, the ecosystem is moving towards the <strong>Component Model</strong>. This abstraction defines a high-level IDL (WIT)
                that allows modules to exchange complex types (strings, records, variants) without shared memory, effectively treating every module as a
                "nano-process" with its own isolated heap. This represents a paradigm shift from monolithic binaries to granular, capability-based composition.
            </p>
        </section>

        <section class="references">
            <h2>Reference Sources</h2>
            <ul class="ref-list">
                <li>
                    <a href="https://github.com/llvm/llvm-project/tree/main/llvm/lib/Target/WebAssembly" target="_blank">LLVM WebAssembly Backend</a>
                    <span class="ref-desc"> - The upstream source for the TargetMachine, instruction selection, and the Stackifier pass.</span>
                </li>
                <li>
                    <a href="https://webassembly.github.io/spec/core/" target="_blank">WebAssembly Core Specification</a>
                    <span class="ref-desc"> - The formal definition of the virtual machine, validation rules, and binary format.</span>
                </li>
                <li>
                    <a href="https://github.com/WebAssembly/component-model" target="_blank">The Component Model</a>
                    <span class="ref-desc"> - Specifications for high-level module composition and interface types (WIT).</span>
                </li>
                <li>
                    <a href="https://llvm.org/docs/WebAssembly.html" target="_blank">LLVM: WebAssembly Target</a>
                    <span class="ref-desc"> - Official documentation on target features, ABI compatibility, and known issues.</span>
                </li>
                 <li>
                    <a href="https://github.com/WebAssembly/WASI" target="_blank">WASI (WebAssembly System Interface)</a>
                    <span class="ref-desc"> - The standard for system calls, defining capabilities for file I/O, networking, and clocks.</span>
                </li>
            </ul>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 WebAssembly Ecosystem Guide. Built with &hearts; for the Open Web.</p>
        </div>
    </footer>
</body>
</html>